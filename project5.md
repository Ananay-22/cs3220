# CS3220 Assignment #5:  Edge detection FPGA accelerator

**Due date**: **12/3/2021 (F) : 6 pm**

This is a two-member group project.
(10 pts) 

Note: If you are running out of the time for doing this project #5, you can skip running the code in the pynq board and perform only vitis simulation. Vitis simulation only will give you 8 poits out of 10 points. 

**Description**:

In this assignment, you will develop an edge detection mechanism using FPGA. 
To help you to design the accelerator, we provide a base implementation. The edge detection mechanism is based on the sobel edge algorithm. You can find the background knowledge at <a href="https://en.wikipedia.org/wiki/Sobel_operator"> wiki </a>

The sobel edge algorithm is built on top of the convolution function so we are offloading convolution operations in the FPGA. The convolution operations are built on using Vitis HLS and the rest of interface code is running on python. 


Due to the limited schedule, we provide versions that already include some optimizations. Your job is to understand what optimizations are applied. 
Improving the performance over what we provide will be a bonus point. 


*Part-1: Vitis-Only (10 pts)*  Understanding the HLS compiler's outcome reports. We provide two different versions of convolution code to show different optimizations. 
From the report that is generated by vitis, you can see the compiler already performs loop unrolling, loop pipeling and other optimizations. Please look at solution/Open Report (Synthesis) and Solution/Open Schedule Viewer to analyze the results. 

In your report, based on the synthesized report from vitis, you need to explain what optimizations are performed and how they were succesful.  Please compare two different versions of the code to discuss.  You need to explain at least 3 different optimized locations (explain what the optimization is doing, where the code is, and scheduling chart of the code, and whether the optimization was indeed succesful or not) 
<img src="figs/vitis_dynamic_schedule.png"> 
e.g.) 
KERNEL_INIT
a snipet of code 
loop unrolling and pipeling are performed by the compiler. 
timing chart shows that add/compute/write are pipelined but still have idle cycles. 




*Part-2 (From vitis to Pynq boards) Optional task * 

Now with the vitis code, you repeat the steps in HW#12. Instead "add+5"in HW#11, you substitue the example module with part-1' example IR. The steps to produce the vivado IR is the same as HW#12. Alternateivly, you can just upgrade the example IP module from HW#12's design. 
 <img src="figs/upgrade_ip.png">
Now, we provide two different notebooks to test your vitis design. 

cv_edge_arm.ipynb and cv_edge_fpga.ipynb. 

cv_edge_arm performs sobel edge detection using ARM processors. Every operations are performed using python code. 
In cv_edge_fpga, convolution operations are offloaded to FPGA. 


*Bonus Points (up to 5 pts)* 

If you are able to improve the performance on FPGA (at least 5%), you will receive bonus 5 points. If you only optimize your code into vitis and shows at least 5% latency reduction, you will receive bonus 2 points. 

Further optimization opportunities are 

Array partition 
Loop unrolling 
Utilize data flow 
Convert convolution operations as dense matrix multiplication 
Reduce the number of bits 
Improve the DMA features 

Note: 
You can reduce the number of bits for computation. 
You cannot reduce the image resolution. 
You can increase the scope of offloading beyond the convolution operations. 
You can also look at the convolution hls code that you have used in hw9(algorithm_2D_convolution_linebuffer). 
You can use different data structures to speed up the code. 
You cannot use the convolution IP module 


**What to submit** 
 
project5_report.pdf:







